<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C - General-Purpose Programming Language</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body>
    <nav class="navbar">
        <div class="nav-brand">
            <a href="index.html">CodeLearn Hub</a>
        </div>
        <div class="nav-menu">
            <a href="index.html" class="nav-link">Home</a>
            <a href="index.html#programming-languages" class="nav-link">Languages</a>
            <a href="index.html#coding-schemes" class="nav-link">Schemes</a>
            <a href="index.html#number-system" class="nav-link">Number System</a>
            <a href="index.html#compiler" class="nav-link">Compiler</a>
            <a href="index.html#challenges" class="nav-link">Challenges</a>
            <a href="index.html#progress" class="nav-link">Progress</a>
            <a href="index.html#ai-bot" class="nav-link">AI Bot</a>
            <a href="index.html#oop" class="nav-link">OOP</a>
        </div>
        <div class="hamburger">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </nav>

    <main class="main-content">
        <div class="language-detail-page">
            <div class="page-header">
                <h1>ðŸ”µ C</h1>
                <p>General-purpose programming language that provides low-level access to memory and system resources</p>
            </div>

            <div class="language-overview">
                <div class="overview-card">
                    <h2>Language Overview</h2>
                    <p>C is a general-purpose, procedural programming language supporting structured programming, lexical variable scope, and recursion, with a static type system. By design, C provides constructs that map efficiently to typical machine instructions, making it suitable for system programming and embedded systems.</p>
                    
                    <div class="language-stats">
                        <div class="stat">
                            <div class="stat-label">First Released</div>
                            <div class="stat-value">1972</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Latest Standard</div>
                            <div class="stat-value">C18/C2x</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Paradigm</div>
                            <div class="stat-value">Procedural</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Typing</div>
                            <div class="stat-value">Static, Weak</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="language-sections">
                <!-- Key Features -->
                <div class="section-card">
                    <h3>Key Features</h3>
                    <div class="features-grid">
                        <div class="feature-item">
                            <h4>Low-Level Access</h4>
                            <p>Direct memory manipulation and hardware access</p>
                        </div>
                        <div class="feature-item">
                            <h4>Portability</h4>
                            <p>Code can be compiled on different platforms</p>
                        </div>
                        <div class="feature-item">
                            <h4>Efficiency</h4>
                            <p>Fast execution and minimal memory overhead</p>
                        </div>
                        <div class="feature-item">
                            <h4>Standard Library</h4>
                            <p>Rich set of built-in functions and utilities</p>
                        </div>
                    </div>
                </div>

                <!-- Basic Syntax -->
                <div class="section-card">
                    <h3>Basic Syntax</h3>
                    <div class="code-example">
                        <pre><code>// Hello World program
#include &lt;stdio.h&gt;

int main() {
    printf("Hello, World!\n");
    return 0;
}

// Variables and data types
#include &lt;stdio.h&gt;

int main() {
    // Integer types
    int number = 42;
    short small = 100;
    long big = 1000000L;
    
    // Floating point types
    float pi = 3.14f;
    double precise = 3.14159265359;
    
    // Character type
    char letter = 'A';
    
    // Arrays
    int numbers[5] = {1, 2, 3, 4, 5};
    
    // Pointers
    int *ptr = &number;
    
    printf("Number: %d, Pointer: %p\n", number, ptr);
    return 0;
}</code></pre>
                    </div>
                </div>

                <!-- Functions -->
                <div class="section-card">
                    <h3>Functions</h3>
                    <div class="code-example">
                        <pre><code>#include &lt;stdio.h&gt;

// Function declaration (prototype)
int add(int a, int b);
void printMessage(const char* message);

int main() {
    int result = add(10, 20);
    printf("Result: %d\n", result);
    
    printMessage("Hello from function!");
    return 0;
}

// Function definition
int add(int a, int b) {
    return a + b;
}

void printMessage(const char* message) {
    printf("%s\n", message);
}

// Recursive function
int factorial(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}</code></pre>
                    </div>
                </div>

                <!-- Pointers and Memory -->
                <div class="section-card">
                    <h3>Pointers and Memory</h3>
                    <div class="code-example">
                        <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    // Basic pointer usage
    int x = 10;
    int *ptr = &x;
    
    printf("Value of x: %d\n", x);
    printf("Address of x: %p\n", (void*)&x);
    printf("Value at ptr: %d\n", *ptr);
    
    // Dynamic memory allocation
    int *dynamicArray = (int*)malloc(5 * sizeof(int));
    
    if (dynamicArray != NULL) {
        // Initialize array
        for (int i = 0; i < 5; i++) {
            dynamicArray[i] = i + 1;
        }
        
        // Use array
        for (int i = 0; i < 5; i++) {
            printf("%d ", dynamicArray[i]);
        }
        printf("\n");
        
        // Free memory
        free(dynamicArray);
    }
    
    return 0;
}</code></pre>
                    </div>
                </div>

                <!-- Structures -->
                <div class="section-card">
                    <h3>Structures</h3>
                    <div class="code-example">
                        <pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// Structure definition
struct Person {
    char name[50];
    int age;
    float height;
};

// Structure with pointer
struct Student {
    char* name;
    int id;
    float gpa;
};

int main() {
    // Creating and using structures
    struct Person person1;
    strcpy(person1.name, "John Doe");
    person1.age = 30;
    person1.height = 175.5;
    
    printf("Name: %s, Age: %d, Height: %.1f\n", 
           person1.name, person1.age, person1.height);
    
    // Structure pointers
    struct Person *ptr = &person1;
    printf("Name via pointer: %s\n", ptr->name);
    
    // Array of structures
    struct Person people[3] = {
        {"Alice", 25, 165.0},
        {"Bob", 35, 180.0},
        {"Charlie", 28, 170.0}
    };
    
    for (int i = 0; i < 3; i++) {
        printf("Person %d: %s, %d, %.1f\n", 
               i+1, people[i].name, people[i].age, people[i].height);
    }
    
    return 0;
}</code></pre>
                    </div>
                </div>

                <!-- File I/O -->
                <div class="section-card">
                    <h3>File I/O</h3>
                    <div class="code-example">
                        <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    FILE *file;
    char buffer[100];
    
    // Writing to file
    file = fopen("test.txt", "w");
    if (file != NULL) {
        fprintf(file, "Hello, this is a test file!\n");
        fprintf(file, "Line 2: C programming is fun!\n");
        fclose(file);
        printf("File written successfully!\n");
    }
    
    // Reading from file
    file = fopen("test.txt", "r");
    if (file != NULL) {
        printf("File contents:\n");
        while (fgets(buffer, sizeof(buffer), file) != NULL) {
            printf("%s", buffer);
        }
        fclose(file);
    }
    
    // Binary file operations
    int numbers[] = {1, 2, 3, 4, 5};
    file = fopen("data.bin", "wb");
    if (file != NULL) {
        fwrite(numbers, sizeof(int), 5, file);
        fclose(file);
        printf("Binary file written!\n");
    }
    
    return 0;
}</code></pre>
                    </div>
                </div>

                <!-- Preprocessor Directives -->
                <div class="section-card">
                    <h3>Preprocessor Directives</h3>
                    <div class="code-example">
                        <pre><code>#include &lt;stdio.h&gt;

// Macro definitions
#define PI 3.14159
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define SQUARE(x) ((x) * (x))

// Conditional compilation
#define DEBUG 1

int main() {
    double radius = 5.0;
    double area = PI * SQUARE(radius);
    
    printf("Area of circle: %.2f\n", area);
    printf("Maximum of 10 and 20: %d\n", MAX(10, 20));
    
    #if DEBUG
        printf("Debug mode is enabled\n");
    #endif
    
    #ifdef PI
        printf("PI is defined as: %f\n", PI);
    #endif
    
    return 0;
}</code></pre>
                    </div>
                </div>

                <!-- Common Libraries -->
                <div class="section-card">
                    <h3>Common Libraries</h3>
                    <div class="features-grid">
                        <div class="feature-item">
                            <h4>stdio.h</h4>
                            <p>Input/output operations and file handling</p>
                        </div>
                        <div class="feature-item">
                            <h4>stdlib.h</h4>
                            <p>Memory allocation, random numbers, utilities</p>
                        </div>
                        <div class="feature-item">
                            <h4>string.h</h4>
                            <p>String manipulation functions</p>
                        </div>
                        <div class="feature-item">
                            <h4>math.h</h4>
                            <p>Mathematical functions and constants</p>
                        </div>
                    </div>
                </div>

                <!-- Best Practices -->
                <div class="section-card">
                    <h3>Best Practices</h3>
                    <div class="best-practices">
                        <div class="practice-item">
                            <h4>Memory Management</h4>
                            <p>Always free allocated memory and check for NULL pointers</p>
                        </div>
                        <div class="practice-item">
                            <h4>Error Handling</h4>
                            <p>Check return values and handle errors appropriately</p>
                        </div>
                        <div class="practice-item">
                            <h4>Buffer Safety</h4>
                            <p>Use bounds checking to prevent buffer overflows</p>
                        </div>
                        <div class="practice-item">
                            <h4>Code Organization</h4>
                            <p>Use header files for function declarations and constants</p>
                        </div>
                    </div>
                </div>

                <!-- Related Technologies -->
                <div class="section-card">
                    <h3>Related Technologies</h3>
                    <div class="related-tech">
                        <div class="tech-item">
                            <h4>GCC</h4>
                            <p>GNU Compiler Collection for C compilation</p>
                        </div>
                        <div class="tech-item">
                            <h4>Make</h4>
                            <p>Build automation tool for C projects</p>
                        </div>
                        <div class="tech-item">
                            <h4>GDB</h4>
                            <p>GNU Debugger for debugging C programs</p>
                        </div>
                        <div class="tech-item">
                            <h4>Valgrind</h4>
                            <p>Memory error detection tool</p>
                        </div>
                    </div>
                </div>

                <!-- Complete C Reference -->
                <div class="section-card">
                    <h3>ðŸ”µ Complete C Reference</h3>
                    <div class="resources-grid">
                        <div class="resource-item">
                            <h4>Pointers & Memory Management</h4>
                            <div class="code-example">
                                <pre><code>// Pointer basics and memory allocation
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    // Basic pointers
    int x = 42;
    int *ptr = &x;
    
    printf("Value: %d, Address: %p\n", x, (void*)&x);
    printf("Pointer value: %d, Pointer address: %p\n", *ptr, (void*)ptr);
    
    // Dynamic memory allocation
    int *dynamic_array = (int*)malloc(5 * sizeof(int));
    if (dynamic_array == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        return 1;
    }
    
    // Initialize array
    for (int i = 0; i < 5; i++) {
        dynamic_array[i] = i * 10;
    }
    
    // Use array
    for (int i = 0; i < 5; i++) {
        printf("dynamic_array[%d] = %d\n", i, dynamic_array[i]);
    }
    
    // Free memory
    free(dynamic_array);
    dynamic_array = NULL; // Good practice
    
    // Function pointers
    int (*operation)(int, int);
    
    int add(int a, int b) { return a + b; }
    int multiply(int a, int b) { return a * b; }
    
    operation = add;
    printf("5 + 3 = %d\n", operation(5, 3));
    
    operation = multiply;
    printf("5 * 3 = %d\n", operation(5, 3));
    
    return 0;
}</code></pre>
                            </div>
                        </div>
                        <div class="resource-item">
                            <h4>Data Structures & Algorithms</h4>
                            <div class="code-example">
                                <pre><code>// Linked list implementation
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Create new node
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Insert at beginning
Node* insertAtBeginning(Node* head, int data) {
    Node* newNode = createNode(data);
    newNode->next = head;
    return newNode;
}

// Insert at end
Node* insertAtEnd(Node* head, int data) {
    Node* newNode = createNode(data);
    
    if (head == NULL) {
        return newNode;
    }
    
    Node* current = head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = newNode;
    return head;
}

// Print list
void printList(Node* head) {
    Node* current = head;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

// Free list
void freeList(Node* head) {
    Node* current = head;
    Node* next;
    
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
}

int main() {
    Node* head = NULL;
    
    head = insertAtBeginning(head, 10);
    head = insertAtBeginning(head, 20);
    head = insertAtEnd(head, 30);
    head = insertAtEnd(head, 40);
    
    printf("Linked List: ");
    printList(head);
    
    freeList(head);
    return 0;
}</code></pre>
                            </div>
                        </div>
                        <div class="resource-item">
                            <h4>File I/O & Binary Operations</h4>
                            <div class="code-example">
                                <pre><code>// Advanced file operations
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// Structure for binary file
typedef struct {
    int id;
    char name[50];
    float salary;
} Employee;

// Write employee to file
int writeEmployee(FILE* file, Employee* emp) {
    return fwrite(emp, sizeof(Employee), 1, file);
}

// Read employee from file
int readEmployee(FILE* file, Employee* emp) {
    return fread(emp, sizeof(Employee), 1, file);
}

// Search employee by ID
Employee* findEmployeeById(const char* filename, int id) {
    FILE* file = fopen(filename, "rb");
    if (file == NULL) {
        return NULL;
    }
    
    Employee* emp = (Employee*)malloc(sizeof(Employee));
    if (emp == NULL) {
        fclose(file);
        return NULL;
    }
    
    while (readEmployee(file, emp)) {
        if (emp->id == id) {
            fclose(file);
            return emp;
        }
    }
    
    fclose(file);
    free(emp);
    return NULL;
}

// Copy file with progress
int copyFile(const char* source, const char* destination) {
    FILE* src = fopen(source, "rb");
    FILE* dest = fopen(destination, "wb");
    
    if (src == NULL || dest == NULL) {
        if (src) fclose(src);
        if (dest) fclose(dest);
        return 0;
    }
    
    char buffer[4096];
    size_t bytesRead;
    long totalBytes = 0;
    
    while ((bytesRead = fread(buffer, 1, sizeof(buffer), src)) > 0) {
        fwrite(buffer, 1, bytesRead, dest);
        totalBytes += bytesRead;
        
        // Show progress every 1MB
        if (totalBytes % (1024 * 1024) == 0) {
            printf("Copied %ld MB\n", totalBytes / (1024 * 1024));
        }
    }
    
    fclose(src);
    fclose(dest);
    return 1;
}</code></pre>
                            </div>
                        </div>
                        <div class="resource-item">
                            <h4>Advanced C Features & Macros</h4>
                            <div class="code-example">
                                <pre><code>// Advanced preprocessor and macros
#include &lt;stdio.h&gt;

// Variadic macros
#define DEBUG_PRINT(fmt, ...) \
    do { \
        if (DEBUG_MODE) { \
            printf("[DEBUG] " fmt "\n", ##__VA_ARGS__); \
        } \
    } while(0)

// Stringification
#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)

// Token concatenation
#define CONCAT(a, b) a##b

// Compile-time assertions
#define STATIC_ASSERT(condition) \
    typedef char static_assertion[(condition) ? 1 : -1]

// Generic macro using _Generic (C11)
#define PRINT_VALUE(x) _Generic((x), \
    int: printf("Integer: %d\n", x), \
    double: printf("Double: %f\n", x), \
    char*: printf("String: %s\n", x), \
    default: printf("Unknown type\n"))

// Function-like macro with safety
#define SAFE_DIVIDE(a, b) \
    ((b) != 0 ? (a) / (b) : 0)

// Macro for array size
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

// Debug mode flag
#define DEBUG_MODE 1

int main() {
    int numbers[] = {1, 2, 3, 4, 5};
    
    DEBUG_PRINT("Array size: %zu", ARRAY_SIZE(numbers));
    
    printf("Stringified: %s\n", STRINGIFY(Hello World));
    printf("Version: %s\n", TOSTRING(1.0));
    
    int var1 = 42;
    CONCAT(var, 1) = 100; // Creates var1 = 100
    
    STATIC_ASSERT(sizeof(int) == 4);
    
    PRINT_VALUE(42);
    PRINT_VALUE(3.14);
    PRINT_VALUE("Hello");
    
    printf("Safe divide: %d\n", SAFE_DIVIDE(10, 2));
    printf("Safe divide by zero: %d\n", SAFE_DIVIDE(10, 0));
    
    return 0;
}</code></pre>
                            </div>
                        </div>
                        <div class="resource-item">
                            <h4>System Programming & Signals</h4>
                            <div class="code-example">
                                <pre><code>// Signal handling and system calls
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

volatile sig_atomic_t flag = 0;

// Signal handler
void signal_handler(int sig) {
    if (sig == SIGINT) {
        printf("\nReceived SIGINT (Ctrl+C)\n");
        flag = 1;
    } else if (sig == SIGUSR1) {
        printf("Received SIGUSR1\n");
    }
}

// Process creation
int createChildProcess() {
    pid_t pid = fork();
    
    if (pid < 0) {
        perror("Fork failed");
        return -1;
    } else if (pid == 0) {
        // Child process
        printf("Child process: PID = %d, Parent PID = %d\n", 
               getpid(), getppid());
        
        // Simulate work
        sleep(2);
        printf("Child process completed\n");
        exit(0);
    } else {
        // Parent process
        printf("Parent process: PID = %d, Child PID = %d\n", 
               getpid(), pid);
        
        // Wait for child
        int status;
        waitpid(pid, &status, 0);
        
        if (WIFEXITED(status)) {
            printf("Child exited with status: %d\n", WEXITSTATUS(status));
        }
    }
    
    return 0;
}

int main() {
    // Set up signal handlers
    signal(SIGINT, signal_handler);
    signal(SIGUSR1, signal_handler);
    
    printf("Process started. PID: %d\n", getpid());
    printf("Press Ctrl+C to exit or send SIGUSR1\n");
    
    // Create child process
    createChildProcess();
    
    // Main loop
    while (!flag) {
        printf("Main process running...\n");
        sleep(1);
    }
    
    printf("Exiting main process\n");
    return 0;
}</code></pre>
                            </div>
                        </div>
                        <div class="resource-item">
                            <h4>Optimization & Performance</h4>
                            <div class="code-example">
                                <pre><code>// Performance optimization techniques
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;

// Inline function for small operations
static inline int min(int a, int b) {
    return (a < b) ? a : b;
}

// Optimized string copy
void optimized_strcpy(char* dest, const char* src) {
    // Copy 4 bytes at a time (assuming 32-bit system)
    size_t len = strlen(src);
    size_t i = 0;
    
    // Copy word by word
    while (i + 3 < len) {
        *(int*)(dest + i) = *(int*)(src + i);
        i += 4;
    }
    
    // Copy remaining bytes
    while (i < len) {
        dest[i] = src[i];
        i++;
    }
    dest[len] = '\0';
}

// Cache-friendly matrix multiplication
void matrix_multiply_optimized(int* a, int* b, int* result, int n) {
    // Transpose matrix B for better cache locality
    int* b_transposed = (int*)malloc(n * n * sizeof(int));
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            b_transposed[j * n + i] = b[i * n + j];
        }
    }
    
    // Multiply with transposed matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            int sum = 0;
            for (int k = 0; k < n; k++) {
                sum += a[i * n + k] * b_transposed[j * n + k];
            }
            result[i * n + j] = sum;
        }
    }
    
    free(b_transposed);
}

// Memory pool for frequent allocations
typedef struct MemoryPool {
    char* buffer;
    size_t size;
    size_t used;
} MemoryPool;

MemoryPool* create_memory_pool(size_t size) {
    MemoryPool* pool = (MemoryPool*)malloc(sizeof(MemoryPool));
    pool->buffer = (char*)malloc(size);
    pool->size = size;
    pool->used = 0;
    return pool;
}

void* pool_alloc(MemoryPool* pool, size_t size) {
    if (pool->used + size > pool->size) {
        return NULL; // Pool full
    }
    
    void* ptr = pool->buffer + pool->used;
    pool->used += size;
    return ptr;
}</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script src="script.js"></script>
</body>
</html>
