<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fortran Programming Language - Learn Everything About Fortran</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body>
    <div class="language-detail-page">
        <header class="language-header">
            <div class="header-content">
                <div class="language-icon">
                    <i class="fas fa-calculator"></i>
                </div>
                <div class="language-info">
                    <h1>Fortran Programming Language</h1>
                    <p class="language-tagline">"Formula Translation" - The first high-level programming language, designed for scientific computing</p>
                    <div class="language-meta">
                        <span class="meta-item"><i class="fas fa-calendar"></i> Created: 1957</span>
                        <span class="meta-item"><i class="fas fa-user"></i> Creator: IBM (John Backus)</span>
                        <span class="meta-item"><i class="fas fa-code"></i> Paradigm: Procedural, Imperative</span>
                    </div>
                </div>
            </div>
            <a href="index.html" class="back-btn"><i class="fas fa-arrow-left"></i> Back to Home</a>
        </header>

        <div class="language-overview">
            <div class="overview-card">
                <h2>Language Overview</h2>
                <p>Fortran (Formula Translation) is one of the oldest high-level programming languages, originally developed by IBM for scientific and engineering applications. It has evolved through multiple standards (FORTRAN 66, FORTRAN 77, Fortran 90, Fortran 95, Fortran 2003, Fortran 2008, Fortran 2018) and remains widely used in high-performance computing, numerical analysis, and scientific simulations.</p>
                
                <div class="language-stats">
                    <div class="stat">
                        <div class="stat-value">66+</div>
                        <div class="stat-label">Years Active</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">8</div>
                        <div class="stat-label">Major Standards</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">1M+</div>
                        <div class="stat-label">Lines of Code</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="language-sections">
            <div class="section-card">
                <h3>Key Features</h3>
                <div class="features-grid">
                    <div class="feature-item">
                        <i class="fas fa-rocket"></i>
                        <h4>High Performance</h4>
                        <p>Optimized for numerical computations and scientific applications</p>
                    </div>
                    <div class="feature-item">
                        <i class="fas fa-calculator"></i>
                        <h4>Mathematical Operations</h4>
                        <p>Built-in support for complex arithmetic and mathematical functions</p>
                    </div>
                    <div class="feature-item">
                        <i class="fas fa-vector-square"></i>
                        <h4>Array Operations</h4>
                        <p>Efficient array handling with built-in array operations</p>
                    </div>
                    <div class="feature-item">
                        <i class="fas fa-microchip"></i>
                        <h4>Parallel Computing</h4>
                        <p>Modern Fortran supports OpenMP and MPI for parallel processing</p>
                    </div>
                </div>
            </div>

            <div class="section-card">
                <h3>Basic Syntax</h3>
                <div class="syntax-examples">
                    <div class="code-example">
                        <h4>Hello World</h4>
                        <pre><code>program hello
  implicit none
  
  print *, "Hello, World!"
  
end program hello</code></pre>
                    </div>
                    <div class="code-example">
                        <h4>Variable Declarations</h4>
                        <pre><code>program variables
  implicit none
  
  ! Variable declarations
  integer :: age
  real :: height, weight
  character(len=20) :: name
  logical :: is_student
  
  ! Assignment
  age = 25
  height = 175.5
  weight = 70.2
  name = "Alice"
  is_student = .true.
  
end program variables</code></pre>
                    </div>
                    <div class="code-example">
                        <h4>Arrays</h4>
                        <pre><code>program arrays
  implicit none
  
  ! Array declarations
  integer, dimension(5) :: numbers
  real, dimension(3,3) :: matrix
  character(len=10), dimension(4) :: names
  
  ! Array initialization
  numbers = [1, 2, 3, 4, 5]
  matrix = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3, 3])
  names = ["Alice", "Bob", "Charlie", "Diana"]
  
end program arrays</code></pre>
                    </div>
                </div>
            </div>

            <div class="section-card">
                <h3>Control Structures</h3>
                <div class="control-flow-grid">
                    <div class="flow-item">
                        <h4>Conditionals</h4>
                        <pre><code>program conditionals
  implicit none
  
  integer :: age
  
  age = 25
  
  if (age >= 18) then
    print *, "Adult"
  else if (age >= 13) then
    print *, "Teenager"
  else
    print *, "Child"
  end if
  
  ! Single line if
  if (age >= 18) print *, "Can vote"
  
end program conditionals</code></pre>
                    </div>
                    <div class="flow-item">
                        <h4>Loops</h4>
                        <pre><code>program loops
  implicit none
  
  integer :: i, sum
  
  ! Do loop
  sum = 0
  do i = 1, 10
    sum = sum + i
  end do
  
  ! Do while loop
  i = 1
  do while (i <= 5)
    print *, i
    i = i + 1
  end do
  
  ! Do loop with step
  do i = 10, 1, -1
    print *, i
  end do
  
end program loops</code></pre>
                    </div>
                </div>
            </div>

            <div class="section-card">
                <h3>Functions and Subroutines</h3>
                <div class="functions-grid">
                    <div class="function-item">
                        <h4>Function Definition</h4>
                        <pre><code>program functions
  implicit none
  
  real :: result
  
  result = calculate_area(5.0, 3.0)
  print *, "Area:", result
  
contains
  
  function calculate_area(length, width) result(area)
    real, intent(in) :: length, width
    real :: area
    
    area = length * width
  end function calculate_area
  
end program functions</code></pre>
                    </div>
                    <div class="function-item">
                        <h4>Subroutine</h4>
                        <pre><code>program subroutines
  implicit none
  
  real :: x, y, sum, product
  
  x = 10.0
  y = 5.0
  
  call calculate_values(x, y, sum, product)
  print *, "Sum:", sum, "Product:", product
  
contains
  
  subroutine calculate_values(a, b, s, p)
    real, intent(in) :: a, b
    real, intent(out) :: s, p
    
    s = a + b
    p = a * b
  end subroutine calculate_values
  
end program subroutines</code></pre>
                    </div>
                </div>
            </div>

            <div class="section-card">
                <h3>Array Operations</h3>
                <div class="data-structures-grid">
                    <div class="structure-item">
                        <h4>Array Manipulation</h4>
                        <pre><code>program array_ops
  implicit none
  
  integer, dimension(5) :: arr1, arr2, result
  real, dimension(3,3) :: matrix
  
  ! Array initialization
  arr1 = [1, 2, 3, 4, 5]
  arr2 = [10, 20, 30, 40, 50]
  
  ! Element-wise operations
  result = arr1 + arr2
  print *, "Sum:", result
  
  result = arr1 * arr2
  print *, "Product:", result
  
  ! Matrix operations
  matrix = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3, 3])
  print *, "Matrix:"
  call print_matrix(matrix)
  
contains
  
  subroutine print_matrix(mat)
    real, dimension(:,:), intent(in) :: mat
    integer :: i, j
    
    do i = 1, size(mat, 1)
      do j = 1, size(mat, 2)
        write(*, '(F8.2)', advance='no') mat(i, j)
      end do
      print *
    end do
  end subroutine print_matrix
  
end program array_ops</code></pre>
                    </div>
                    <div class="structure-item">
                        <h4>Array Functions</h4>
                        <pre><code>program array_functions
  implicit none
  
  real, dimension(5) :: data
  real :: max_val, min_val, sum_val, avg_val
  
  data = [3.14, 2.71, 1.41, 2.24, 1.73]
  
  ! Built-in array functions
  max_val = maxval(data)
  min_val = minval(data)
  sum_val = sum(data)
  avg_val = sum_val / size(data)
  
  print *, "Data:", data
  print *, "Max:", max_val
  print *, "Min:", min_val
  print *, "Sum:", sum_val
  print *, "Average:", avg_val
  
  ! Array slicing
  print *, "First 3 elements:", data(1:3)
  print *, "Every other element:", data(1:5:2)
  
end program array_functions</code></pre>
                    </div>
                </div>
            </div>

            <div class="section-card">
                <h3>Modules and Derived Types</h3>
                <div class="libraries-grid">
                    <div class="library-item">
                        <h4>Module Definition</h4>
                        <pre><code>module math_utils
  implicit none
  
  ! Module variables
  real, parameter :: PI = 3.14159265359
  
  ! Module procedures
  contains
  
  function circle_area(radius) result(area)
    real, intent(in) :: radius
    real :: area
    
    area = PI * radius * radius
  end function circle_area
  
  function factorial(n) result(fact)
    integer, intent(in) :: n
    integer :: fact, i
    
    fact = 1
    do i = 2, n
      fact = fact * i
    end do
  end function factorial
  
end module math_utils</code></pre>
                    </div>
                    <div class="library-item">
                        <h4>Using Modules</h4>
                        <pre><code>program use_module
  use math_utils
  implicit none
  
  real :: radius, area
  integer :: n, fact
  
  radius = 5.0
  area = circle_area(radius)
  print *, "Circle area:", area
  
  n = 5
  fact = factorial(n)
  print *, n, "! =", fact
  
end program use_module</code></pre>
                    </div>
                </div>
            </div>

            <div class="section-card">
                <h3>File I/O</h3>
                <div class="file-handling-content">
                    <h4>Reading Files</h4>
                    <pre><code>program file_read
  implicit none
  
  integer :: unit, iostat
  character(len=100) :: line
  real :: number
  
  ! Open file for reading
  open(unit=10, file='data.txt', status='old', action='read')
  
  ! Read file line by line
  do
    read(10, '(A)', iostat=iostat) line
    if (iostat /= 0) exit
    print *, trim(line)
  end do
  
  ! Close file
  close(10)
  
end program file_read</code></pre>
                    
                    <h4>Writing Files</h4>
                    <pre><code>program file_write
  implicit none
  
  integer :: i
  real :: x, y
  
  ! Open file for writing
  open(unit=20, file='output.txt', status='replace', action='write')
  
  ! Write data to file
  do i = 1, 10
    x = real(i)
    y = x * x
    write(20, *) x, y
  end do
  
  ! Close file
  close(20)
  
end program file_write</code></pre>
                </div>
            </div>

            <div class="section-card">
                <h3>Modern Fortran Features</h3>
                <div class="semantic-grid">
                    <div class="semantic-item">
                        <h4>Dynamic Arrays</h4>
                        <pre><code>program dynamic_arrays
  implicit none
  
  integer, allocatable :: arr(:)
  integer :: n, i
  
  print *, "Enter array size:"
  read *, n
  
  ! Allocate array
  allocate(arr(n))
  
  ! Initialize array
  do i = 1, n
    arr(i) = i * i
  end do
  
  print *, "Array:", arr
  
  ! Deallocate array
  deallocate(arr)
  
end program dynamic_arrays</code></pre>
                    </div>
                    <div class="semantic-item">
                        <h4>Pointers</h4>
                        <pre><code>program pointers
  implicit none
  
  integer, pointer :: ptr(:)
  integer, target :: target_array(5)
  integer :: i
  
  ! Initialize target array
  do i = 1, 5
    target_array(i) = i
  end do
  
  ! Associate pointer with target
  ptr => target_array
  
  ! Use pointer
  print *, "Pointer values:", ptr
  
  ! Modify through pointer
  ptr(1) = 100
  print *, "Modified target:", target_array
  
end program pointers</code></pre>
                    </div>
                </div>
            </div>

            <div class="section-card">
                <h3>Best Practices</h3>
                <div class="best-practices">
                    <div class="practice-item">
                        <i class="fas fa-check-circle"></i>
                        <h4>Always use implicit none</h4>
                        <p>Prevents implicit variable declarations and catches typos</p>
                    </div>
                    <div class="practice-item">
                        <i class="fas fa-check-circle"></i>
                        <h4>Use intent attributes</h4>
                        <p>Specify whether parameters are input, output, or both</p>
                    </div>
                    <div class="practice-item">
                        <i class="fas fa-check-circle"></i>
                        <h4>Proper array bounds</h4>
                        <p>Always check array bounds to avoid runtime errors</p>
                    </div>
                    <div class="practice-item">
                        <i class="fas fa-check-circle"></i>
                        <h4>Use modules for organization</h4>
                        <p>Organize related procedures and data in modules</p>
                    </div>
                </div>
            </div>

            <div class="section-card">
                <h3>Related Technologies</h3>
                <div class="related-tech">
                    <div class="tech-item">
                        <i class="fas fa-microchip"></i>
                        <h4>Parallel Computing</h4>
                        <p>OpenMP, MPI, Coarrays, CUDA Fortran</p>
                    </div>
                    <div class="tech-item">
                        <i class="fas fa-calculator"></i>
                        <h4>Numerical Libraries</h4>
                        <p>LAPACK, BLAS, FFTW, NetCDF, HDF5</p>
                    </div>
                    <div class="tech-item">
                        <i class="fas fa-rocket"></i>
                        <h4>High Performance Computing</h4>
                        <p>Supercomputers, clusters, GPU computing</p>
                    </div>
                    <div class="tech-item">
                        <i class="fas fa-flask"></i>
                        <h4>Scientific Applications</h4>
                        <p>Climate modeling, physics simulations, engineering analysis</p>
                    </div>
                </div>
            </div>

            <!-- Complete Fortran Reference -->
            <div class="section-card">
                <h3>ðŸ”¬ Complete Fortran Reference</h3>
                <div class="resources-grid">
                    <div class="resource-item">
                        <h4>Modern Fortran Features & Scientific Computing</h4>
                        <div class="code-example">
                            <pre><code>! Modern Fortran scientific computing examples
program scientific_computing
    use, intrinsic :: iso_fortran_env, only: real64, int32
    use, intrinsic :: ieee_arithmetic
    implicit none
    
    ! Parameterized derived types
    type :: matrix_t(k, rows, cols)
        integer, kind :: k = real64
        integer, len :: rows, cols
        real(k) :: data(rows, cols)
    contains
        procedure :: multiply => matrix_multiply
        procedure :: transpose => matrix_transpose
        procedure :: determinant => matrix_determinant
    end type matrix_t
    
    ! Advanced array operations
    integer, parameter :: n = 1000
    real(real64), dimension(n, n) :: a, b, c
    real(real64), dimension(n) :: x, y
    integer :: i, j
    
    ! Initialize arrays with array constructors
    x = [(real(i, real64), i = 1, n)]
    y = [(sin(real(i, real64) * 0.01), i = 1, n)]
    
    ! Vectorized operations
    where (x > 0.0_real64)
        y = sqrt(x)
    elsewhere
        y = 0.0_real64
    end where
    
    ! Matrix operations using intrinsic procedures
    call random_number(a)
    call random_number(b)
    
    ! Matrix multiplication
    c = matmul(a, b)
    
    ! Elemental functions
    c = sin(a) + cos(b)
    
contains
    
    ! Pure function for numerical integration
    pure function simpson_rule(f, a, b, n) result(integral)
        interface
            pure function f(x) result(y)
                import :: real64
                real(real64), intent(in) :: x
                real(real64) :: y
            end function f
        end interface
        real(real64), intent(in) :: a, b
        integer, intent(in) :: n
        real(real64) :: integral
        
        real(real64) :: h, sum_odds, sum_evens
        integer :: i
        
        h = (b - a) / real(n, real64)
        sum_odds = 0.0_real64
        sum_evens = 0.0_real64
        
        do i = 1, n-1, 2
            sum_odds = sum_odds + f(a + i * h)
        end do
        
        do i = 2, n-2, 2
            sum_evens = sum_evens + f(a + i * h)
        end do
        
        integral = h / 3.0_real64 * (f(a) + 4.0_real64 * sum_odds + &
                   2.0_real64 * sum_evens + f(b))
    end function simpson_rule
    
    ! Elemental function for array operations
    elemental function gaussian(x, mu, sigma) result(y)
        real(real64), intent(in) :: x, mu, sigma
        real(real64) :: y
        real(real64), parameter :: pi = 4.0_real64 * atan(1.0_real64)
        
        y = exp(-0.5_real64 * ((x - mu) / sigma)**2) / (sigma * sqrt(2.0_real64 * pi))
    end function gaussian
    
end program scientific_computing

! Module for linear algebra operations
module linear_algebra
    use, intrinsic :: iso_fortran_env, only: real64
    implicit none
    private
    public :: solve_linear_system, eigenvalues, svd_decomposition
    
contains
    
    ! Solve linear system using LU decomposition
    subroutine solve_linear_system(a, b, x, info)
        real(real64), intent(inout) :: a(:,:)
        real(real64), intent(inout) :: b(:)
        real(real64), intent(out) :: x(:)
        integer, intent(out) :: info
        
        integer :: n, i, j, k, pivot
        real(real64) :: factor, temp
        integer, allocatable :: perm(:)
        
        n = size(a, 1)
        allocate(perm(n))
        perm = [(i, i = 1, n)]
        info = 0
        
        ! LU decomposition with partial pivoting
        do k = 1, n-1
            ! Find pivot
            pivot = k
            do i = k+1, n
                if (abs(a(perm(i), k)) > abs(a(perm(pivot), k))) then
                    pivot = i
                end if
            end do
            
            ! Swap rows
            if (pivot /= k) then
                temp = perm(k)
                perm(k) = perm(pivot)
                perm(pivot) = int(temp)
            end if
            
            ! Check for singular matrix
            if (abs(a(perm(k), k)) < epsilon(1.0_real64)) then
                info = k
                return
            end if
            
            ! Eliminate
            do i = k+1, n
                factor = a(perm(i), k) / a(perm(k), k)
                do j = k+1, n
                    a(perm(i), j) = a(perm(i), j) - factor * a(perm(k), j)
                end do
                b(perm(i)) = b(perm(i)) - factor * b(perm(k))
            end do
        end do
        
        ! Back substitution
        do i = n, 1, -1
            x(i) = b(perm(i))
            do j = i+1, n
                x(i) = x(i) - a(perm(i), j) * x(j)
            end do
            x(i) = x(i) / a(perm(i), i)
        end do
        
        deallocate(perm)
    end subroutine solve_linear_system
    
end module linear_algebra</code></pre>
                        </div>
                    </div>
                    <div class="resource-item">
                        <h4>High Performance Computing & Parallelization</h4>
                        <div class="code-example">
                            <pre><code>! High-performance computing with OpenMP and Coarrays
program parallel_computing
    use, intrinsic :: iso_fortran_env, only: real64
    use omp_lib
    implicit none
    
    integer, parameter :: n = 10000
    real(real64), dimension(n, n) :: a, b, c
    real(real64) :: start_time, end_time
    integer :: i, j, k, num_threads
    
    ! OpenMP parallel matrix multiplication
    call omp_set_num_threads(4)
    num_threads = omp_get_max_threads()
    print *, 'Using', num_threads, 'threads'
    
    ! Initialize matrices
    call random_number(a)
    call random_number(b)
    
    start_time = omp_get_wtime()
    
    !$omp parallel do private(i, j, k) shared(a, b, c)
    do i = 1, n
        do j = 1, n
            c(i, j) = 0.0_real64
            do k = 1, n
                c(i, j) = c(i, j) + a(i, k) * b(k, j)
            end do
        end do
    end do
    !$omp end parallel do
    
    end_time = omp_get_wtime()
    print *, 'Matrix multiplication time:', end_time - start_time, 'seconds'
    
    ! Parallel reduction example
    call parallel_sum_example()
    
    ! Coarray example for distributed computing
    call coarray_example()
    
contains
    
    subroutine parallel_sum_example()
        integer, parameter :: array_size = 1000000
        real(real64), dimension(array_size) :: data
        real(real64) :: total_sum, partial_sum
        integer :: i, thread_id
        
        ! Initialize data
        data = [(real(i, real64), i = 1, array_size)]
        total_sum = 0.0_real64
        
        !$omp parallel private(partial_sum, thread_id)
        thread_id = omp_get_thread_num()
        partial_sum = 0.0_real64
        
        !$omp do
        do i = 1, array_size
            partial_sum = partial_sum + data(i)**2
        end do
        !$omp end do
        
        !$omp critical
        total_sum = total_sum + partial_sum
        print *, 'Thread', thread_id, 'partial sum:', partial_sum
        !$omp end critical
        
        !$omp end parallel
        
        print *, 'Total sum:', total_sum
    end subroutine parallel_sum_example
    
    subroutine coarray_example()
        ! Coarray programming for distributed memory
        integer, parameter :: local_size = 1000
        real(real64), dimension(local_size)[*] :: local_data
        real(real64) :: global_sum, local_sum
        integer :: i, img, num_images
        
        num_images = num_images()
        
        ! Initialize local data on each image
        do i = 1, local_size
            local_data(i) = real(this_image() * local_size + i, real64)
        end do
        
        ! Compute local sum
        local_sum = sum(local_data)
        
        ! Synchronize all images
        sync all
        
        ! Collect results on image 1
        if (this_image() == 1) then
            global_sum = local_sum
            do img = 2, num_images
                global_sum = global_sum + sum(local_data(:)[img])
            end do
            print *, 'Global sum across', num_images, 'images:', global_sum
        end if
        
        sync all
    end subroutine coarray_example
    
end program parallel_computing

! Advanced numerical methods module
module numerical_methods
    use, intrinsic :: iso_fortran_env, only: real64
    implicit none
    private
    public :: runge_kutta_4, newton_raphson, monte_carlo_pi
    
contains
    
    ! Fourth-order Runge-Kutta method for ODEs
    subroutine runge_kutta_4(f, y0, t0, tf, n, y, t)
        interface
            function f(t, y) result(dydt)
                import :: real64
                real(real64), intent(in) :: t, y
                real(real64) :: dydt
            end function f
        end interface
        real(real64), intent(in) :: y0, t0, tf
        integer, intent(in) :: n
        real(real64), intent(out) :: y(0:n), t(0:n)
        
        real(real64) :: h, k1, k2, k3, k4
        integer :: i
        
        h = (tf - t0) / real(n, real64)
        t(0) = t0
        y(0) = y0
        
        do i = 1, n
            k1 = h * f(t(i-1), y(i-1))
            k2 = h * f(t(i-1) + h/2, y(i-1) + k1/2)
            k3 = h * f(t(i-1) + h/2, y(i-1) + k2/2)
            k4 = h * f(t(i-1) + h, y(i-1) + k3)
            
            y(i) = y(i-1) + (k1 + 2*k2 + 2*k3 + k4) / 6
            t(i) = t0 + i * h
        end do
    end subroutine runge_kutta_4
    
    ! Newton-Raphson method for root finding
    function newton_raphson(f, df, x0, tol, max_iter) result(root)
        interface
            function f(x) result(y)
                import :: real64
                real(real64), intent(in) :: x
                real(real64) :: y
            end function f
            function df(x) result(dy)
                import :: real64
                real(real64), intent(in) :: x
                real(real64) :: dy
            end function df
        end interface
        real(real64), intent(in) :: x0, tol
        integer, intent(in) :: max_iter
        real(real64) :: root
        
        real(real64) :: x, fx, dfx
        integer :: iter
        
        x = x0
        do iter = 1, max_iter
            fx = f(x)
            dfx = df(x)
            
            if (abs(dfx) < epsilon(1.0_real64)) then
                print *, 'Derivative too small, stopping'
                exit
            end if
            
            x = x - fx / dfx
            
            if (abs(fx) < tol) then
                print *, 'Converged in', iter, 'iterations'
                exit
            end if
        end do
        
        root = x
    end function newton_raphson
    
end module numerical_methods</code></pre>
                        </div>
                    </div>
                    <div class="resource-item">
                        <h4>Advanced I/O & File Processing</h4>
                        <div class="code-example">
                            <pre><code>! Advanced I/O operations and file processing
program advanced_io
    use, intrinsic :: iso_fortran_env, only: real64, int32, iostat_end
    implicit none
    
    character(len=100) :: filename
    integer :: unit_num, iostat
    
    ! Binary file I/O example
    call binary_file_example()
    
    ! Formatted I/O with custom formats
    call formatted_io_example()
    
    ! Stream I/O for large datasets
    call stream_io_example()
    
    ! NetCDF-style data processing
    call scientific_data_processing()
    
contains
    
    subroutine binary_file_example()
        integer, parameter :: n = 1000
        real(real64), dimension(n, n) :: matrix
        integer :: i, j, unit
        
        ! Create test data
        do i = 1, n
            do j = 1, n
                matrix(i, j) = sin(real(i, real64)) * cos(real(j, real64))
            end do
        end do
        
        ! Write binary file
        open(newunit=unit, file='matrix_data.bin', form='unformatted', &
             access='stream', status='replace')
        write(unit) n, n
        write(unit) matrix
        close(unit)
        
        ! Read binary file
        matrix = 0.0_real64
        open(newunit=unit, file='matrix_data.bin', form='unformatted', &
             access='stream', status='old')
        read(unit) i, j  ! dimensions
        read(unit) matrix(1:i, 1:j)
        close(unit)
        
        print *, 'Binary I/O completed. Matrix(1,1) =', matrix(1,1)
    end subroutine binary_file_example
    
    subroutine formatted_io_example()
        type :: person_t
            character(len=50) :: name
            integer :: age
            real(real64) :: salary
        end type person_t
        
        type(person_t), dimension(3) :: people
        integer :: i, unit
        character(len=*), parameter :: fmt = '(a50, i5, f12.2)'
        
        ! Initialize data
        people(1) = person_t('John Doe', 30, 50000.0_real64)
        people(2) = person_t('Jane Smith', 25, 45000.0_real64)
        people(3) = person_t('Bob Johnson', 35, 60000.0_real64)
        
        ! Write formatted file
        open(newunit=unit, file='people.txt', status='replace')
        write(unit, '(a)') '# Name                Age    Salary'
        write(unit, '(a)') '# ====================================='
        do i = 1, size(people)
            write(unit, fmt) people(i)%name, people(i)%age, people(i)%salary
        end do
        close(unit)
        
        ! Read formatted file with error handling
        people = person_t('', 0, 0.0_real64)  ! Reset
        open(newunit=unit, file='people.txt', status='old')
        
        ! Skip header lines
        read(unit, *)
        read(unit, *)
        
        i = 1
        do
            read(unit, fmt, iostat=iostat) people(i)%name, people(i)%age, people(i)%salary
            if (iostat /= 0) exit
            i = i + 1
            if (i > size(people)) exit
        end do
        close(unit)
        
        print *, 'Read', i-1, 'records from file'
    end subroutine formatted_io_example
    
    subroutine stream_io_example()
        integer, parameter :: buffer_size = 1024
        character(len=buffer_size) :: buffer
        integer :: unit, pos, bytes_read
        character(len=1) :: char
        integer :: word_count, line_count
        logical :: in_word
        
        ! Process large text file character by character
        open(newunit=unit, file='large_text.txt', access='stream', &
             form='unformatted', status='old', iostat=iostat)
        
        if (iostat /= 0) then
            print *, 'Creating sample file...'
            call create_sample_text_file()
            open(newunit=unit, file='large_text.txt', access='stream', &
                 form='unformatted', status='old')
        end if
        
        word_count = 0
        line_count = 0
        in_word = .false.
        pos = 1
        
        do
            read(unit, pos=pos, iostat=iostat) char
            if (iostat /= 0) exit
            
            select case (char)
            case (' ', char(9))  ! Space or tab
                in_word = .false.
            case (char(10), char(13))  ! Newline
                line_count = line_count + 1
                in_word = .false.
            case default
                if (.not. in_word) then
                    word_count = word_count + 1
                    in_word = .true.
                end if
            end select
            
            pos = pos + 1
        end do
        
        close(unit)
        print *, 'File statistics: Words =', word_count, ', Lines =', line_count
    end subroutine stream_io_example
    
    subroutine create_sample_text_file()
        integer :: unit, i
        
        open(newunit=unit, file='large_text.txt', status='replace')
        do i = 1, 1000
            write(unit, '(a, i0, a)') 'This is line ', i, ' of the sample text file.'
        end do
        close(unit)
    end subroutine create_sample_text_file
    
    subroutine scientific_data_processing()
        ! Simulate processing scientific datasets
        integer, parameter :: nx = 100, ny = 100, nt = 50
        real(real64), dimension(nx, ny, nt) :: temperature
        real(real64), dimension(nx, ny) :: avg_temp, max_temp
        integer :: i, j, t, unit
        
        ! Generate synthetic temperature data
        do t = 1, nt
            do j = 1, ny
                do i = 1, nx
                    temperature(i, j, t) = 20.0_real64 + 10.0_real64 * &
                        sin(2.0_real64 * 3.14159_real64 * real(t, real64) / real(nt, real64)) * &
                        exp(-((real(i-nx/2, real64))**2 + (real(j-ny/2, real64))**2) / 1000.0_real64)
                end do
            end do
        end do
        
        ! Compute statistics
        avg_temp = sum(temperature, dim=3) / real(nt, real64)
        max_temp = maxval(temperature, dim=3)
        
        ! Write results in scientific format
        open(newunit=unit, file='temperature_analysis.dat', status='replace')
        write(unit, '(a)') '# Temperature Analysis Results'
        write(unit, '(a)') '# x y avg_temp max_temp'
        do j = 1, ny
            do i = 1, nx
                write(unit, '(2i5, 2f12.4)') i, j, avg_temp(i, j), max_temp(i, j)
            end do
        end do
        close(unit)
        
        print *, 'Scientific data processing completed'
        print *, 'Average temperature range:', minval(avg_temp), 'to', maxval(avg_temp)
    end subroutine scientific_data_processing
    
end program advanced_io</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="script.js"></script>
</body>
</html>
